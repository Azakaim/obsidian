Гвидо Ван Россум - создатель языка. Разрабатывал скриптовый расширяемый язык на досуге . Назван в честь скетч-шоу 'Monty Python’s Flying Circus' ('Летающий цирк Монти Пайтон'). В феврале 1991 года опубликован в новостной сводке группы alt.sources. В 2008 году вышла версия языка 3000 - python3.0. Срок поддержки версии языка 2.7 истек 1 января 2020 года. Поддержка идет от версии 3.6.
Тим Питерс, известный инженер-программист и один из разработчиков ядра основного интерпретатора Python в 1999 г придумал стихотворение которе вместило негласные правила написания и оно стало называться [[Python дзен]]
Ключевая идея Гвидо такова: ккод читается больше раз чем пишеться . Поэтомук как говорится в PEP 20, "Читабельность имеет значение".  
В [[Python]] pep8 это документ-соглашение как надо писать код. Официальное руководство по стилю. Включая стандартную библиотеку входящую в состав python. 

**Пробелы и оступы**

**4 пробела на каждый уровень отступа отступа .**

**Продолджительные строки с нависающим отступом или заключать перносимое в круглые скобки.**

Правильно:
```
#Выровнено по открывающему разделителю
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

#Добавлено 4 пробела (следующий уровень отступа) для выделения аргумента от остальных
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)
```
Неправильно:
```
# Аргументы на первой строке запрещены, если не используется вертикальное выравнивание
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# Больше отступов требуется для выделения аргумента от остальных
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)
```
 для if else для нескольких строк 4 пробела 
 ```
 # Без дополнительных отступов
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# Добавьте комментарий, который обеспечит некоторое разграничение в редакторах, поддерживающих подсветку синтаксиса
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# Добавьте несколько дополнительных отступов в строке продолжении
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
```

Закрывающие скобки (),[],{} должны закрываться под первым непробельным символом последней строки списка например:
```
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
```
либо под первым символом строки начианющим мнгострочную констуркцию
```
my_list = [
1, 2, 3,
4, 5, 6,
]
result = some_function_that_takes_arguments(
'a', 'b', 'c',
'd', 'e', 'f',
)
```

**Пробелы против табуляции**

**Предпочтительны пробелы не табуляция.**

- **Пробелы**:
    
    - **Предпочтительный метод**: PEP 8, официальное руководство по стилю Python, рекомендует использовать пробелы для отступов. Это значит, что вы должны использовать 4 пробела для каждого уровня отступа.
    - **Преимущества**: Пробелы обеспечивают единообразие и предсказуемость. Все разработчики видят один и тот же отступ, независимо от настроек их текстового редактора.
- **Табуляция**:
    
    - **Используйте только для поддержки**: Табуляция может использоваться, если вы работаете с кодом, который уже использует табуляцию для отступов. Однако это не рекомендуется, так как это может привести к путанице.
    - **Проблемы**: Разные текстовые редакторы могут отображать табуляцию по-разному (например, один редактор может показывать табуляцию как 4 пробела, а другой — как 8). Это может привести к тому, что код будет выглядеть по-разному у разных разработчиков.

**Максимальная длинна строки 79 симовлов**

**Комментариев в 72**

**Длинные строки заключаем в скобки и пренос а длинных строк тройные кавычки**
```
text = """Первая строка 
Вторая строка 
Третья строка"""
```
**Для преноса строк так же используется косая черта** ==\\==
```
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```
Еще одно применение [assert](https://sky.pro/media/ispolzovanie-operatora-assert-v-python/)

**Когда разделять строку после или до бинарных операторов**

На протяжении десятилетий рекомендовалось разрывать строку после бинарных операторов. Но Дональд Кнут объясняет традиционное правило в своей серии "Компьютеры и набор текста":
Правильно:
```
# Легко сопоставлять операторы с операндами
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```
Неправильно:
```
# Легко сопоставлять операторы с операндами
income = (gross_wages +
		  taxable_interest +
          (dividends - qualified_dividends) - 
          ira_deduction -
          student_loan_interest)
```
Для нового кода рекомендуется **использовать стиль Кнута**. 

Верхний уровень пример:
```
class MyClass:
    def method_one(self):
        print("Method One")

def my_function():
    print("This is a function")

```
Нижний уровень пример:
```
class MyClass:
    def method_one(self):
        print("Method One")

def my_function():
    print("This is a function")

	def nested_function():# это нижний уровень
		print("This is a nested function")
```

**Функции верхнего уровня отделяйте двумя пустыми строками друг от друга.** 

Пример:
```
class MyClass:
    def method_one(self):
        print("Method One")

    def method_two(self):
        print("Method Two")


def my_function():
    print("This is a function")


class AnotherClass:
    def another_method(self):
        print("Another Method")

```

**Определение методов внутри класса отделяются одной пустой строкой**
```
class MyClass:
    def method_one(self):
        print("Method One")

    def method_two(self):
        print("Method Two")

```
  
  **Фиктивные функции или например абстарктные методы а так же однострочные можно не отделять пустыми строками**
  
```
def add(a, b):
    return a + b
def subtract(a, b):
    return a - b
def multiply(a, b):
    return a * b
def divide(a, b):
    return a / b

```

**Внутри методов дял разделения логических блоков одну строку можно пустую использовать.**

```
def process_data(data):
    # Шаг 1: Очистка данных
    cleaned_data = [d.strip() for d in data if d]

    # Шаг 2: Обработка данных
    processed_data = [d.lower() for d in cleaned_data]

    return processed_data
```

Каждый импорт, как правило, должен быть на отдельной строке.

Правильно:
```
import os
import sys
```

Неправильно:
```
import sys, os
```

В то же время, можно писать так:
```
from subprocess import Popen, PIPE
```

**Импорты всегдла в начлао файла и пред обьявлением констант**

==Импорты должны быть сгруппированы в следующем порядке:==

1. ==импорты из стандартной библиотеки==

2. ==импорты сторонних библиотек==

3. ==импорты модулей текущего проекта==

**Вставляйте пустую строку между каждой группой импортов.**

**Рекомендуется абсолютное импортирование**

```
import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example
```

явный отнсительный импорт так же премлим

```
from . import sibling
from .sibling import example
```

 **Происхождение имен `foo` и `bar`**

**Историческое использование**: Имена `foo` и `bar` имеют долгую историю в программировании и часто используются в учебных примерах. Они происходят из языка программирования **B**, который был предшественником языка **C**. В языке B использовались имена `foo`, `bar`, и `baz` как временные обозначения для переменных и функций.

wildcard-импорты (from `module` import **) следует избегать непонятно каие имена пристутвуют в глобальном пространстве имен и используются за звездочкой

[Dunder-методы](https://tproger.ru/articles/dunder-metody-zachem-oni-nuzhny-i-chto-mogut)
Dunder (сокращение от double underscore - двойное подчекривание) или магические методы  __all__, __author__, __version__ и т.д. Должны распологаться после строки документации модуля, но перед любым выражением import, за исключением импортов __future__. Python предписывает, что импорты __future__ должны появляться в модуле перед любым другим кодом, за исключением строки документации.
```
"""This is the example module.

This module does stuff.
"""

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys
```
Самый яркий дандер-метод котрый мы с тобой знаем это ```__init__```
,перопределяя дандер метод мы как бы преопредляем встроенный в класс обджект метод от которго все наследуется и задем то поведение кторое нам нужно . Например словари складывать нельзя а мы это сделаем блягодаря dunder-методу:
```
class AddableDict(dict):

    def __add__(self, otherObj):
        self.update(otherObj)
        return AddableDict(self)


dict1 = AddableDict({1 : "ABC"})
dict2 = AddableDict({2 : "EFG"})

print (dict1 + dict2)
```
И хопа на ))
```
{1: 'ABC', 2: 'EFG'}
```

**Соглашению о docstring в PEP 257 гласит** что для тройных кавычек использовать всегда двойные. В отсальном и одинарные для коротких строк и двойные для длинных можно использовать.

#### Пробелы в выражениях и инструкциях

Правильно:
```
spam(ham[0], {egs:2}) 
```

Неправильно:
```
spam( ham[ 1 ], { eggs: 2 } )
```

Между запятой и последующей закрытой скобкой.

Правильно:
```
foo = (0,)# это кстати создание кортежа если бы (0) без , - число
```

Неправильно:
```
bar = (0, )
```

Непосредственно перед запятой, точкой с запятой или двоеточием.

Правильно:
```
if x == 4 : print(x, y); x, y = y, x 
```

Неправильно:
```
if x == 4 : print(x , y) ; x , y = y , x
```

Когда в срезе двоеточие используется как бинарный оператор. Должен имет ьравное кол-во пробелов с обеих сторон. В расширенном срезе должно быть одинаковое кол-во интервалов. Исключение: если параметр среза опущен пробел не ставится.

Правильно:
```
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]
```

Неправильно:
```
ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
ham[lower : : step]
ham[ : upper]
```

Сразу перед открывающей скобкой, после которой начинается список аргументов при вызове функции.

Правильно:
```
spam(1)
```

Неправильно:
```
spam (1)
```

Сразу перед открывающей скобкой, после которой следует индекс или срез.

Правильно:
```
dict['key'] = list[index]
```

Неправильно:
```
dict ['key'] = list [index]
```

Использование более одного пробела вокруг оператора присваивания (или любого другого) для того, чтобы выровнять его с другим

Правильно:
```
x = 1
y = 2
long_variable = 3
```

Неправильно:
```
x             = 1
y             = 2
long_variable = 3
```

- Всегда окружайте эти бинарные операторы одним пробелом с каждой стороны: присваивания (=, +=, -= и другие), сравнения (`==`, <, >, !=, <>, <=, >=, in, not in, is, is not), логические (and, or, not).

- Если используются операторы с разными приоритетами, попробуйте добавить пробелы вокруг операторов с самым низким приоритетом. Используйте свои собственные суждения, однако, никогда не используйте более одного пробела, и всегда используйте одинаковое количество пробелов по обе стороны бинарного оператора.

Правильно:
```
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
```

Неправильно:
```
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
```

Аннотации функций должны использовать обычные правила для двоеточий и всегда иметь пробелы вокруг стрелки ->, если она присутствует.

Правильно:
```
def munge(input: AnyStr): ...
def munge() -> PosInt: ...
```

Неправильно:
```
def munge(input:AnyStr): ...
def munge()->PosInt: ...
```

Не используйте пробелы вокруг знака =, если он используется для обозначения именованного аргумента или значения параметров по умолчанию.

Правильно:
```
def complex(real, imag=0.0):
	return magic(r=real, i=imag)
```

Неправильно:
```
def complex(real, imag = 0.0):
	return magic(r = real, i = imag)
```

Однако при объединении аннотации аргумента со значением по умолчанию используйте пробелы вокруг знака =.

Правильно:
```
def munge(sep: AnyStr = None): ...
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...
```

Неправильно:
```
def munge(input: AnyStr=None): ...
def munge(input: AnyStr, limit = 1000): ...
```

Не используйте составные инструкции (несколько команд в одной строке).

Правильно:
```
if foo == 'blah':
	do_blah_thing()
do_one()
do_two()
do_three()
```

Неправильно:
```
if foo == 'blah': do_blah_thing()
do_one(); do_two(); do_three()
```

- Иногда можно писать тело циклов while, for или ветку if в той же строке, если команда короткая, но если команд несколько, никогда так не пишите. А также избегайте длинных строк!

Точно неправильно:
```
if foo == 'blah': do_blah_thing()
for x in lst: total += x
while t < 10: t = delay()

```

Вероятно, неправильно:

```
if foo == 'blah': do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
							 list, like, this)

if foo == 'blah': one(); two(); three()
```
