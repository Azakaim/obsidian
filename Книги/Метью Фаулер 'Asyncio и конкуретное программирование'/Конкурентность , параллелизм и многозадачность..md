**Многозадачность** — свойство операционной системы или среды программирования, обеспечивать возможность параллельной (или псевдопараллельной) обработки нескольких процессов

==Конкурентность== - это когда 2 задачи выполняются (условно)одновременно. Условно пока греется духовка мы ==переключаемся== на приготовление торта ,а первый торт допустим должен отстоятся и мы не ждем этого а ==переключаемся== на приготовление второго торта. Так вот такое ==переключение== и есть пример конкурентного поведения.

==Параллелизм== - это когда 2 задачи выполняются строго ==в одно и то же время== . То есть если бы например я позвал второго повара или помощника и мы готовили первый и второй торт ==одновременно==.

Тоже самое и с процессором с ==1 ядром ,он способен на конкурентность==, когда несколько задач могут работать независимо друг от друга применив ==вытесняющую многозадачность== .А вот ==процессор с 2мя ядрами== нам уже даст ==параллелизм==. Кстати праллелизм подразумевает конкуреность т.к я одним ядром она возможна а не наоборот.

Виды ***Многозадачности***:

==Вытесняющая многозадачность== при таком виде многозадачности мы позволяем системе самой решать как перключатся между выполненим задач с помощью механизма ***[[Квант времени]]*** (==Квантование времени== - когда процессор тратит время на задачу называется квантом времени процессора. ==Квант времени== - это ==время== в течение которого ==ОС позволяет работать== потоку (==процессу==) ==непрерывно==. ==По истечении времени, поток вытесняется другим== ) Такое ==преключение - вытяснение==. Распределение процессорного времени осуществляется планировщиком процессов в ОС по алогоритму Round Robin(вкруг пo loop)

==Кооперативная многозадачность или невытесняющая многозадачность== - мы сами указываем и определяем точки ,где можно уступить управление другой задаче. Так вот ==Asyncio== это как раз ==про кооперативную многозадачность== раз уж мы сами определяем когда и что выполнять всмысле задач для процессора))

В ==Asyncio== для организации конкурентности мы используем коопертивную многозадачность про это я выше писал. Короче thread(нить) потока в помечнном нами месте await засыпает для вычисления а мы двигаемся дальше по коду это все в очереди событийного-loop происходит и так как по циклу от await к await основной поток бегает пока не выполнятся все корутины. 

Коопретаивная многозадачность выгодна ОС и нам потому что она потребялет меньше ресурсов ,т.к когда ==ОС нужно переключится между потоками или процессами== (это мы называем ==контекстное переключение==) и это трудоемкая оперция ведь при переключении контекста нужно куда-то записать инфу о том что там навычисляли в работающем процессе или потоке, что бы потом ее возобновить. 

Контекстное переключение — это трудоемкая операция, которая включает в себя несколько шагов:

1. **Сохранение состояния**: Операционная система должна сохранить текущее состояние работающего процесса или потока. Это включает в себя регистры процессора, указатели стека и другие данные, необходимые для возобновления работы процесса в будущем.
    
2. **Загрузка состояния**: После сохранения состояния текущего процесса ОС загружает состояние следующего процесса или потока, который будет выполняться. Это также включает в себя восстановление регистров и указателей, чтобы процесс мог продолжить выполнение с того места, где он был приостановлен.
    
3. **Управление памятью**: В некоторых случаях может потребоваться переключение контекста на уровне памяти, что также требует дополнительных ресурсов. Это может включать в себя обновление таблиц страниц и кэширование данных.
    
4. **Синхронизация**: При переключении между потоками или процессами необходимо учитывать синхронизацию, особенно если они взаимодействуют друг с другом. Это может потребовать дополнительных затрат на управление блокировками и семафорами.

То ли дело с коопертивной многзадачностью где всем управляем мы через Asyncio.
Однако стоит отметить, что кооперативная многозадачность требует от разработчиков более тщательного управления временем выполнения задач, чтобы избежать ситуаций, когда одна задача может блокировать выполнение других, что может привести к снижению отзывчивости системы.

Например: Может получится чт онапример ответ от сервреа не приходит 10000 секунд и это была последняя корутина в очереиди и ссответвнно весь основной поток затсрянет на ожидании этой корутины.
### Как избежать блокировки

Чтобы избежать таких ситуаций, можно использовать несколько подходов:

1. **Установка тайм-аутов**   
2. **Обработка ошибок**
3. Использовать `asyncio.wait()` для управления несколькими корутинами и обработки их завершения с учетом тайм-аутов

В общем ==преимущество коопертивной многозадачности в управление контекстным переключением и гранулярности== (это возможност ьзадачу разбит ьна подзадачи и управлять ими так же эффктивно и ассинхронно)

- **Высокая гранулярность**: Позволяет разбивать задачи на более мелкие части, что улучшает отзывчивость системы. Когда корутины выполняют небольшие части работы и периодически передают управление, это позволяет другим задачам выполняться без задержек.
    
- **Эффективное использование ресурсов**: Высокая гранулярность позволяет более эффективно использовать ресурсы системы, так как корутины могут выполнять небольшие части работы и освобождать процессор для других задач, когда они ожидают завершения операций ввода-вывода.
